-- =========================================
-- Base de datos de viáticos / tickets
-- Compatible con PostgreSQL 13+
-- =========================================

-- Extensiones útiles
CREATE EXTENSION IF NOT EXISTS pgcrypto;   -- por si luego usas UUID/crypto
CREATE EXTENSION IF NOT EXISTS citext;     -- para correos/usuarios case-insensitive

-- =========================================
-- Enums / catálogos fijos
-- =========================================

-- Roles de usuario (ROLES.nombre)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'role_nombre') THEN
    CREATE TYPE role_nombre AS ENUM ('supervisor', 'admin', 'empleado');
  END IF;
END$$;

-- Estados de solicitudes (SOLICITUD_AUMENTO / SOLICITUD_ACTUALIZACION)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'solicitud_estado') THEN
    CREATE TYPE solicitud_estado AS ENUM ('pendiente','aceptado','declinado');
  END IF;
END$$;

-- Estado de ticket
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ticket_estado') THEN
    CREATE TYPE ticket_estado AS ENUM ('abierto','cerrado','archivado');
  END IF;
END$$;

-- Monedas (puedes ampliar más adelante)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'currency_code') THEN
    CREATE TYPE currency_code AS ENUM ('GTQ','USD');
  END IF;
END$$;

-- Tipo de gasto (ajusta a tus categorías reales)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'expense_type') THEN
    CREATE TYPE expense_type AS ENUM (
      'alimentacion','hospedaje','transporte',
      'combustible','peajes','estacionamiento','otros'
    );
  END IF;
END$$;

-- =========================================
-- Función y trigger para updated_at automático
-- =========================================
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.actualizado_en := NOW();
  RETURN NEW;
END$$;

-- =========================================
-- Tablas maestras
-- =========================================

-- ROLES
CREATE TABLE IF NOT EXISTS roles (
  id_rol        INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre        role_nombre NOT NULL UNIQUE,             -- 'supervisor' | 'admin' | 'empleado'
  descripcion   TEXT
);

-- MINISTERIOS
CREATE TABLE IF NOT EXISTS ministerios (
  id_ministerio   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre          TEXT NOT NULL UNIQUE,
  activo          BOOLEAN NOT NULL DEFAULT TRUE,
  usuario         CITEXT UNIQUE,                         -- si deseas login por ministerio
  password_hash   TEXT,                                  -- hash (no guardar contraseñas en claro)
  creado_en       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  actualizado_en  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
DROP TRIGGER IF EXISTS trg_ministerios_updated ON ministerios;
CREATE TRIGGER trg_ministerios_updated
BEFORE UPDATE ON ministerios
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- USUARIOS
CREATE TABLE IF NOT EXISTS usuarios (
  id_usuario     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_rol         INT NOT NULL REFERENCES roles(id_rol) ON UPDATE CASCADE,
  id_ministerio  INT NOT NULL REFERENCES ministerios(id_ministerio) ON UPDATE CASCADE,
  nombre         TEXT NOT NULL,
  correo         CITEXT UNIQUE,                          -- opcional pero recomendado
  usuario        CITEXT UNIQUE NOT NULL,                 -- login único (case-insensitive)
  password_hash  TEXT NOT NULL,                          -- hash seguro (p.ej. argon2/bcrypt)
  nit_persona    TEXT,                                   -- patrón: dígitos/letra y guion, sin espacios
  creado_en      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  actualizado_en TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT usuarios_nit_chk CHECK (
    nit_persona IS NULL OR nit_persona ~ '^[0-9]+-?[0-9kK]$'
  )
);
DROP TRIGGER IF EXISTS trg_usuarios_updated ON usuarios;
CREATE TRIGGER trg_usuarios_updated
BEFORE UPDATE ON usuarios
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Índices de acceso frecuente
CREATE INDEX IF NOT EXISTS idx_usuarios_ministerio ON usuarios(id_ministerio);
CREATE INDEX IF NOT EXISTS idx_usuarios_rol        ON usuarios(id_rol);

-- =========================================
-- TICKETS y su historial
-- =========================================

-- TICKETS
CREATE TABLE IF NOT EXISTS tickets (
  id_ticket               INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_usuario_creador      INT NOT NULL REFERENCES usuarios(id_usuario) ON UPDATE CASCADE,
  id_usuario_beneficiario INT NOT NULL REFERENCES usuarios(id_usuario) ON UPDATE CASCADE,
  fecha_inicio            DATE NOT NULL,
  fecha_fin               DATE,
  moneda                  currency_code NOT NULL DEFAULT 'GTQ',
  monto_presupuestado     NUMERIC(14,2) NOT NULL DEFAULT 0,
  total_gastado           NUMERIC(14,2) NOT NULL DEFAULT 0,
  estado                  ticket_estado NOT NULL DEFAULT 'abierto',
  creado_en               TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  actualizado_en          TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT tickets_rango_fechas_chk CHECK (fecha_fin IS NULL OR fecha_fin >= fecha_inicio),
  CONSTRAINT tickets_montos_chk CHECK (monto_presupuestado >= 0 AND total_gastado >= 0)
);
DROP TRIGGER IF EXISTS trg_tickets_updated ON tickets;
CREATE TRIGGER trg_tickets_updated
BEFORE UPDATE ON tickets
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE INDEX IF NOT EXISTS idx_tickets_beneficiario ON tickets(id_usuario_beneficiario);
CREATE INDEX IF NOT EXISTS idx_tickets_creador      ON tickets(id_usuario_creador);
CREATE INDEX IF NOT EXISTS idx_tickets_estado       ON tickets(estado);

-- TICKET_HISTORIAL
CREATE TABLE IF NOT EXISTS ticket_historial (
  id_historial      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_ticket         INT NOT NULL REFERENCES tickets(id_ticket) ON DELETE CASCADE ON UPDATE CASCADE,
  id_usuario_actor  INT NOT NULL REFERENCES usuarios(id_usuario) ON UPDATE CASCADE, -- admin que actuó
  accion            TEXT NOT NULL,                         -- ej: 'crear','ajustar_presupuesto','cambiar_moneda','cerrar','reabrir'
  monto_anterior    NUMERIC(14,2),
  monto_nuevo       NUMERIC(14,2),
  moneda_anterior   currency_code,
  moneda_nueva      currency_code,
  fecha_efectiva    DATE NOT NULL DEFAULT CURRENT_DATE,
  motivo            TEXT,
  creado_en         TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT historial_montos_chk CHECK (
    (monto_anterior IS NULL OR monto_anterior >= 0) AND
    (monto_nuevo    IS NULL OR monto_nuevo    >= 0)
  )
);

CREATE INDEX IF NOT EXISTS idx_historial_ticket ON ticket_historial(id_ticket);
CREATE INDEX IF NOT EXISTS idx_historial_actor  ON ticket_historial(id_usuario_actor);

-- =========================================
-- COMPROBANTES y solicitudes relacionadas
-- =========================================

-- COMPROBANTES
CREATE TABLE IF NOT EXISTS comprobantes (
  id_comprobante          INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_usuario              INT NOT NULL REFERENCES usuarios(id_usuario) ON UPDATE CASCADE,        -- quien registra
  id_ticket               INT REFERENCES tickets(id_ticket) ON UPDATE CASCADE ON DELETE SET NULL, -- puede ser NULL
  proveedor               TEXT,
  serie                   TEXT,
  numero_factura          TEXT,
  fecha_emision           DATE,
  moneda                  currency_code DEFAULT 'GTQ',
  nit_emisor              TEXT,
  nit_receptor            TEXT,
  total                   NUMERIC(14,2),
  descripcion_sugerida    TEXT,
  tipo_gasto              expense_type DEFAULT 'otros',
  imagen_factura_url      TEXT,
  imagen_hash             TEXT,            -- opcional (deduplicación/forense)
  creado_en               TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  actualizado_en          TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT comp_nit_emisor_chk   CHECK (nit_emisor   IS NULL OR nit_emisor   ~ '^[0-9]+-?[0-9kK]$'),
  CONSTRAINT comp_nit_receptor_chk CHECK (nit_receptor IS NULL OR nit_receptor ~ '^[0-9]+-?[0-9kK]$'),
  CONSTRAINT comp_total_chk        CHECK (total IS NULL OR total >= 0)
);
DROP TRIGGER IF EXISTS trg_comprobantes_updated ON comprobantes;
CREATE TRIGGER trg_comprobantes_updated
BEFORE UPDATE ON comprobantes
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE INDEX IF NOT EXISTS idx_comp_usuario ON comprobantes(id_usuario);
CREATE INDEX IF NOT EXISTS idx_comp_ticket  ON comprobantes(id_ticket);
CREATE INDEX IF NOT EXISTS idx_comp_fecha   ON comprobantes(fecha_emision);

-- SOLICITUD_AUMENTO
CREATE TABLE IF NOT EXISTS solicitud_aumento (
  id_solicitud         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_ticket            INT NOT NULL REFERENCES tickets(id_ticket) ON DELETE CASCADE ON UPDATE CASCADE,
  id_usuario_solicitante INT NOT NULL REFERENCES usuarios(id_usuario) ON UPDATE CASCADE, -- empleado
  descripcion          TEXT,
  monto_solicitado     NUMERIC(14,2) NOT NULL CHECK (monto_solicitado > 0),
  estado               solicitud_estado NOT NULL DEFAULT 'pendiente',
  id_usuario_resolutor INT REFERENCES usuarios(id_usuario) ON UPDATE CASCADE, -- admin, nullable
  creado_en            TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  resuelto_en          TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_sol_aum_ticket   ON solicitud_aumento(id_ticket);
CREATE INDEX IF NOT EXISTS idx_sol_aum_estado   ON solicitud_aumento(estado);
CREATE INDEX IF NOT EXISTS idx_sol_aum_sol      ON solicitud_aumento(id_usuario_solicitante);

-- SOLICITUD_ACTUALIZACION (revisión de comprobantes)
CREATE TABLE IF NOT EXISTS solicitud_actualizacion (
  id_solicitud           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_comprobante         INT NOT NULL REFERENCES comprobantes(id_comprobante) ON DELETE CASCADE ON UPDATE CASCADE,
  id_usuario_solicitante INT NOT NULL REFERENCES usuarios(id_usuario) ON UPDATE CASCADE, -- empleado
  datos_propuestos_json  JSONB NOT NULL,       -- campos propuestos tras OCR/edición
  comentario_empleado    TEXT,
  estado                 solicitud_estado NOT NULL DEFAULT 'pendiente',
  id_usuario_resolutor   INT REFERENCES usuarios(id_usuario) ON UPDATE CASCADE,  -- admin, nullable
  comentario_admin       TEXT,
  creado_en              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  resuelto_en            TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_sol_act_comp    ON solicitud_actualizacion(id_comprobante);
CREATE INDEX IF NOT EXISTS idx_sol_act_estado  ON solicitud_actualizacion(estado);
CREATE INDEX IF NOT EXISTS idx_sol_act_sol     ON solicitud_actualizacion(id_usuario_solicitante);

-- =========================================
-- Relaciones implícitas del diagrama (comentarios)
-- ROLES ||--o{ USUARIOS : asigna
-- MINISTERIOS ||--o{ USUARIOS : agrupa
-- USUARIOS ||--o{ TICKETS : crea_o_beneficia
-- TICKETS ||--o{ TICKET_HISTORIAL : registra
-- TICKETS ||--o{ SOLICITUD_AUMENTO : solicitudes
-- TICKETS ||--o{ COMPROBANTES : cubre
-- USUARIOS ||--o{ COMPROBANTES : registra
-- COMPROBANTES ||--o{ SOLICITUD_ACTUALIZACION : revisiones
-- =========================================

-- (Opcional) Vistas útiles
CREATE OR REPLACE VIEW v_ticket_resumen AS
SELECT
  t.id_ticket,
  t.estado,
  t.moneda,
  t.monto_presupuestado,
  t.total_gastado,
  (t.monto_presupuestado - t.total_gastado) AS saldo,
  t.fecha_inicio,
  t.fecha_fin,
  creador.nombre      AS creador,
  beneficiario.nombre AS beneficiario,
  m.nombre            AS ministerio
FROM tickets t
JOIN usuarios creador      ON creador.id_usuario = t.id_usuario_creador
JOIN usuarios beneficiario ON beneficiario.id_usuario = t.id_usuario_beneficiario
JOIN ministerios m         ON m.id_ministerio = beneficiario.id_ministerio;

-- (Opcional) Política simple: un beneficiario no puede ser creador si no es admin
-- Esto normalmente se controla en aplicación, pero aquí queda una CHECK DEFERRABLE si lo deseas:
-- ALTER TABLE tickets ADD CONSTRAINT ck_creador_es_admin
--   CHECK (
--     EXISTS (SELECT 1
--             FROM usuarios u
--             JOIN roles r ON r.id_rol = u.id_rol
--             WHERE u.id_usuario = id_usuario_creador AND r.nombre = 'admin')
--   ) NOT VALID; -- valida luego con VALIDATE CONSTRAINT